import{aw as i,q as e,p as l,aR as s}from"./chunks/framework.tTD5oJD3.js";const v=JSON.parse('{"title":"每周一题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/one.md","filePath":"interview/one.md","lastUpdated":1721185975000}'),a={name:"interview/one.md"},t=s(`<h1 id="每周一题" tabindex="-1">每周一题 <a class="header-anchor" href="#每周一题" aria-label="Permalink to &quot;每周一题&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">提示</p><p>每周记录一道面试题</p></div><h2 id="一、new-vue-都做了什么" tabindex="-1">一、new Vue()都做了什么？ <a class="header-anchor" href="#一、new-vue-都做了什么" aria-label="Permalink to &quot;一、new Vue()都做了什么？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">总结</p><ol><li>new Vue()是创建 Vue 实例，它内部执行了根实例的初始化过程。</li><li>未来执行挂载时，此过程会递归应用于它的子组件上，最终形成一个有紧密关系的组件实例树</li><li>具体包括以下操作:</li></ol><ul><li>选项合并 用户选项、默认选项</li><li>$children, $refs, $slots, $createElement 等实例属性和方法初始化</li><li>自定义事件处理</li><li>数据响应式处理</li><li>生命周期钩子调用</li><li>可能的挂载</li></ul></div><h2 id="二、vue-的响应式" tabindex="-1">二、vue 的响应式？ <a class="header-anchor" href="#二、vue-的响应式" aria-label="Permalink to &quot;二、vue 的响应式？&quot;">​</a></h2><ol><li>啥是响应式？</li><li>为什么 vue 需要响应式？</li><li>它能给我们带来什么好处？</li><li>vue 的响应式是怎么实现的？有哪些优缺点？</li><li>vue3 中的响应式的新变化？</li></ol><div class="tip custom-block"><p class="custom-block-title">总结</p><ol><li>所谓数据响应式就是用户对数据层做的更改能够触发视图层做出更新响应的机制。</li><li>mvvm 框架中要解决的一个核心问题是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这点的就需要实现一套响应式机制，这样一旦数据发生变化就可以立即做出更新处理。</li><li>以 vue 为例说明，通过数据响应式加上虚拟 DOM 和 patch 算法，可以使我们只需要操作数据，完全不用接触繁琐的 dom 操作，从而大大提升开发效率，降低开发难度。</li><li>vue2 中的数据响应式会根据数据类型来做不同处理，如果是对象则采用 Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是数组则通过覆盖该数组原型的方法，扩展它的 7 个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用 Vue.set/delete 这样特殊的 api 才能生效；对于 es6 中新产生的 Map、Set 这些数据结构不支持等问题。</li><li>为了解决这些问题，vue3 重新编写了这一部分的实现：利用 ES6 的 Proxy 机制代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊 api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的 reactivity 包，使得我们可以更灵活的使用它，我们甚至不需要引入 vue 都可以体验</li></ol></div><h2 id="三、vue-的-nexttick" tabindex="-1">三、vue 的 nextTick？ <a class="header-anchor" href="#三、vue-的-nexttick" aria-label="Permalink to &quot;三、vue 的 nextTick？&quot;">​</a></h2><ul><li>Vue.nextTick( [callback, context] )</li><li>官方定义： 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vm.msg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Hello&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// DOM 还没有更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // DOM 更新了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">总结</p><ol><li>nextTick 是 Vue 提供的一个全局 API，由于 vue 的异步更新策略导致我们对数据的修改不会立刻体现在 dom 变化上，此时如果想要立即获取更新后的 dom 状态，就需要使用这个方法</li><li>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 dom 操作完成后才调用。</li><li>所以当我们想在修改数据后立即看到 dom 执行结果就需要用到 nextTick 方法。</li><li>它会在 callbacks 里面加入我们传入的函数，然后用 timerFunc 异步方式调用它们，首选的异步方式会是 Promise。</li></ol></div><h2 id="四、你知道-key-的作用吗" tabindex="-1">四、你知道 key 的作用吗？ <a class="header-anchor" href="#四、你知道-key-的作用吗" aria-label="Permalink to &quot;四、你知道 key 的作用吗？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">总结</p><ol><li>key 的作用主要是为了更高效的对比虚拟 DOM 中的某个节点是否是相同节点。</li><li>vue 在 patch 过程中判断两个节点是否是相同节点是 key 是一个必要条件，渲染一组列表时，key 往往是唯一标识，所以如果不定义 key 的话，vue 只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个 patch 过程比较低效，影响性能。</li><li>实际使用中在渲染一组列表时 key 必须设置，而且必须是唯一标识，应该避免使用数组索引作为 key，这可能导致一些隐蔽的 bug；vue 中在使用相同标签元素过渡切换时，也会使用 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。</li><li>从源码中可以知道，vue 判断两个节点是否相同时主要判断两者的 key 和元素类型等，因此如果不设置 key，它的值就是 undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的 dom 更新操作，明显是不可取的</li></ol></div>`,13),n=[t];function c(o,p,k,h,r,u){return l(),e("div",null,n)}const m=i(a,[["render",c]]);export{v as __pageData,m as default};
